//MORDELL-WEIL SIEVE FOR QUADRATIC POINTS

/* INPUT: model for projective curve X/\Q; set deg2 of degree 2 divisors on X,
split into sets deg2pb and deg2npb of pullbacks from C(\Q) and not pullbacks
from C(\Q) respectively,
set auts of matrices defining Atkin-Lehner operators on X such that C=X/Gamma 
,where Gamma is the group generated by the AL operators in auts, satisfying
rk(J(C)(\Q))=rk(J(X)(\Q)); set divs of degree 0 divisors that generate a subgroup G \subset J(X)(\Q), 
and an integer I such that I*J(X)(\Q) \subset G,
an abstract abelian group A isomorphic to G such that A.i corresponds to divs[i]
and a number genusC that is the genus of C; if #Gamma=2 also a degree 2 divisor
bp on X that is the pullback of a rational point on C, to be used to embed X^{(2)} in J. */

//This function computes the discriminant of the field a place is defined over.
discQuadPlace:=function(P);
        assert Degree(P) eq 2;
        K:=ResidueClassField(P);
    D:=Discriminant(MaximalOrder(K));
    if IsDivisibleBy(D,4) then
           D:=D div 4;
    end if;
        return D;
end function;

//This function checks whether a degree 2 divisor comes from C(\Q) or not
/*IsPullback:=function(QQ) //not used for N = 57
RR<[u]>:=CoordinateRing(AmbientSpace(X));
M:=auts[1];
row:=[&+[RowSequence(M)[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]];
w:=iso<X->X | row,row>;
if not Pullback(w,QQ) eq 1*QQ then return false; //QQ in rho*C(\Q) => w fixes QQ.
else dec:=Decomposition(1*QQ); //If divisor is sum of two distinct fixed points then not a pullback from C(\Q)
     QQQ:=RepresentativePoint(dec[1][1]);
     if not w(QQQ) eq QQQ then return true; //Means w interchanges two points underlying QQ.
     else if dec[1][2] eq 2 then return true; //Means QQ=2Q for some Q fixed under w so pullback.
          else return false; 
          end if;
     end if;
end if;
end function;*/

IsPullback:=function(QQ,deg2pb,deg2npb) //Not used for N=57
if 1*QQ in deg2pb then return true;
else assert 1*QQ in deg2npb;
return false;
end if;
end function;

//This function verifies the conditions of Theorem 2.1
//Input: degree 2 divisor QQ and prime p of good reduction
IsLonely:=function(QQ,p,X,auts,genusC)
if p eq 2 then return false; end if; //Part of first condition in Theorem
ptlist:=[];
d:=2; //Just there to emphasize that we work on X^{(d)} for d=2.
//We now distinguish between a pair of rational points and a quadratic point
if #Decomposition(QQ) eq 1 then //Quadratic point or double rational point case
Q:=Decomposition(QQ)[1][1];
if not IsIsomorphic(ResidueClassField(Q),Rationals()) then //Quadratic point case
dd:=[1,1]; //This encodes that QQ=Q_1+Q_2 with Q_1 and Q_2 distinct
disc:=discQuadPlace(Q);
K:=QuadraticField(disc); //The quadratic field over which QQ is defined
F:=ResidueClassField(Q);
tf,ii:=IsIsomorphic(F,K);
assert tf; //Sanity check
Q:=[ii(x) : x in Eltseq(RepresentativePoint(Q))]; 
conjQ:=[Conjugate(x) : x in Q];
Append(~ptlist,Q);
Append(~ptlist,conjQ);
else dd:=[2]; //Double rational point case
K:=RationalsAsNumberField();
Q:=[K!a : a in Eltseq(RepresentativePoint(Q))];
Append(~ptlist,Q);
end if;
else dd:=[1,1]; //Two distinct rational points case
K:=RationalsAsNumberField();
ptlist:=[Eltseq(RepresentativePoint(Decomposition(QQ)[1][1])),Eltseq(RepresentativePoint(Decomposition(QQ)[2][1]))];
ptlist:=[[K!a : a in pt] : pt in ptlist];
end if;
OK:=RingOfIntegers(K); //K is the number field over which Q_1, Q_2 are defined
dec:=Factorization(p*OK);
pp:=dec[1][1]; //A prime of K above p
f:=InertiaDegree(pp);
if p eq 3 and f eq 1 then return false; end if; //Condition in theorem
Fp,pi:=ResidueClassField(pp);
Xp:=ChangeRing(X,Fp);
Rp<[u]>:=CoordinateRing(AmbientSpace(Xp));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
ws:=[]; //The set of mod p Atkin-Lehner involution(s)
for M in auts do
    row:=[&+[RowSequence(M)[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]];
    Append(~ws,iso<Xp->Xp | row,row>);
end for;
V,phi:=SpaceOfDifferentialsFirstKind(Xp);
ts:=[hom<V->V | [ (Pullback(wp,phi(V.i)))@@phi -V.i  : i in [1..Genus(X)] ]> : wp in ws];
T:=&+[Image(t): t in ts]; //The space of vanishing differentials
if not p eq 2 then assert Dimension(T) eq Genus(X) - genusC; end if; //cf Remark 3.7.
omegas:=[phi(T.i) : i in [1..Dimension(T)]]; //A basis of vanishing differentials
unif:=UniformizingElement(pp);
matrixseq:=[];
for pt in ptlist do //We now construct the matrix Atilde.
m:=Minimum([Valuation(a,pp) : a in pt | not a eq 0]);
Qred:=[unif^(-m)*a : a in pt]; 
Qtilde:=Xp![Evaluate(a,Place(pp)) : a in Qred]; //The mod p reduction of Q
tQtilde:=UniformizingParameter(Qtilde);
if dd eq [1,1] then
Append(~matrixseq,[(omega/Differential(tQtilde))(Qtilde) : omega in omegas]);
else 
Append(~matrixseq,[(omega/Differential(tQtilde))(Qtilde) : omega in omegas]);
Append(~matrixseq,[((omega/Differential(tQtilde)-(omega/Differential(tQtilde))(Qtilde))/tQtilde)(Qtilde) : omega in omegas]); 
end if;
end for;
Atilde:=Matrix(matrixseq);
if Rank(Atilde) eq d then return true;
else return false;
end if;
end function;

//This function verifies the conditions of Theorem 2.4. It is very similar to
//the previous function.
IsOnlyWithFamily:=function(QQ,p,X,auts,genusC)
ptlist:=[];
d:=2;
if #Decomposition(QQ) eq 1 then 
Q:=Decomposition(QQ)[1][1];
if not IsIsomorphic(ResidueClassField(Q),Rationals()) then
dd:=[1,1];
disc:=discQuadPlace(Q);
K:=QuadraticField(disc);
F:=ResidueClassField(Q);
tf,ii:=IsIsomorphic(F,K);
Q:=[ii(x) : x in Eltseq(RepresentativePoint(Q))];
pt:=Q;
else dd:=[2];
K:=RationalsAsNumberField();
Q:=[K!a : a in Eltseq(RepresentativePoint(Q))];
pt:=Q;
end if;
else dd:=[1,1];
K:=RationalsAsNumberField();
Q:=Eltseq(RepresentativePoint(Decomposition(QQ)[1][1]));
pt:=[K!a : a in Q];
end if;
OK:=RingOfIntegers(K);
dec:=Factorization(p*OK);
pp:=dec[1][1];
f:=InertiaDegree(pp);
if f eq 1 and p eq 2 then return false; end if; //This is the condition in the thm
Fp,pi:=ResidueClassField(pp);
Xp:=ChangeRing(X,Fp);
Rp<[u]>:=CoordinateRing(AmbientSpace(Xp));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]]; 
//Note that this function is only called upon for N \neq 57 so #auts = 1
etap:=iso<Xp -> Xp | row,row>;
V,phi:=SpaceOfDifferentialsFirstKind(Xp);
t:=hom<V->V | [ (Pullback(etap,phi(V.i)))@@phi -V.i  : i in [1..Genus(X)] ]>;
T:=Image(t);
if not p eq 2 then assert Dimension(T) eq Genus(X) - genusC; end if;
omegas:=[phi(T.i) : i in [1..Dimension(T)]];
unif:=UniformizingElement(pp);
m:=Minimum([Valuation(a,pp) : a in pt | not a eq 0]);
Qred:=[unif^(-m)*a : a in pt];
Qtilde:=Xp![Evaluate(a,Place(pp)) : a in Qred];
tQtilde:=UniformizingParameter(Qtilde);
Atilde:=Matrix([[(omega/Differential(tQtilde))(Qtilde) : omega in omegas]]);
if Rank(Atilde) eq d-1 then return true; 
else return false;
end if;
end function;

/*This function translates the info from IsLonely and IsOnlyWithFamily
into the right subgroup of A. Input are a prime p, and a set L of degree 2
divisors on X (the known points). It outputs a subgroup B of A together 
with the inclusion map iA: B --> A and the set W\subset A of possible
B-cosets that IsLonely and IsWithFamily allow. */

ChabautyInfo:=function(L,p,X,auts,genusC,A,divs,deg2pb,deg2npb,I,bp)
Fp:=GF(p);
Xp:=ChangeRing(X,Fp);
pts:={pt : pt in Points(Xp,GF(p^2)) | not IsSingular(pt)}; //The quadratic points on Xp.
pls1p:={Place(Q) : Q in pts | Degree(1*Place(Q)) eq 1}; //Degree 1 places on Xp.
pls2p:={Place(Q) : Q in pts | Degree(1*Place(Q)) eq 2}; //Degree 2 places on Xp.
degr2:={1*pl1 + 1*pl2 : pl1 in pls1p, pl2 in pls1p} join {1*pl : pl in pls2p}; //Degree 2 divisors on Xp.
C,phi,psi:=ClassGroup(Xp);
Z:=FreeAbelianGroup(1);
degr:=hom<C->Z | [ Degree(phi(a))*Z.1 : a in OrderedGenerators(C)]>;
JFp:=Kernel(degr); // This is isomorphic to J_X(\F_p).
divsp:=[reduce(X,Xp,divi) : divi in divs];
bpp:=reduce(X,Xp,bp); //We reduce the divisors and the basepoint
imG:=sub<JFp | [JFp!psi(divp) : divp in divsp]>; //And map them to J_X(\F_p).
pos:={DD : DD in degr2 |(JFp!(I*psi(DD-bpp))) in imG}; //The points in X^{(2)}(\F_p) mapping to the image of J_X(\Q).
redL:={reduce(X,Xp,DD) : DD in L}; //We reduce the known points.
posP:={DD : DD in pos | not DD in redL}; //The set we want contains at least this.
for DD in L do
if #auts eq 1 and IsPullback(DD,deg2pb,deg2npb) then //Case of Theorem 2.4 of the paper.
//#auts eq 1 condition excludes N=57.
if not IsOnlyWithFamily(DD,p,X,auts,genusC) then posP:=posP join {reduce(X,Xp,DD)};
end if;
else if not IsLonely(DD,p,X,auts,genusC) then posP:=posP join {reduce(X,Xp,DD)}; //Case of Theorem 2.1.
end if; end if;
end for; //Now posP gives the possible pts in X^{(2)}(\F_p) that a hypothetical unknown point P could reduce to.
jposP:=Setseq({JFp!(I*psi(DD-bpp)) : DD in posP}); //We compute its image in J_X(\F_p).
h:=hom<A -> JFp | [JFp!psi(divp) : divp in divsp]>; //The map A--> J_X(\F_p).
B:=Kernel(h); 
B,iA:=sub<A|B>;
W:={x@@h : x in jposP}; //Representatives for the B-cosets of A corresponding to jposP.
return W,B,iA;
end function;

/*This function does a precomputation to select the next prime to be used in the
sieve based on the heuristics described in Section 2.4.1 of the paper. 

Input: a subgroup iA: B --> A of A provided by the sieve so far, 
the set primes of primes to be considered in the sieve,
a subset exclprimes of primes that have already been selected before, 
a set jacs of abstract abelian groups such that jacs[i] is isomorphic to J_X(\F_{primes[i]}) 
and a set divlist such that divlist[i] is the sequence of images of the divisors in divs in jacs[i].
Each divisor is represented by its sequence in terms of the generators of jacs[i].
Because these may have different lengths for different i, we artificially added
zeros to make the total length of each sequence 100. */

PrimeSelector:=function(B,iA,primes,exclprimes,jacs,divlist,X)
ratios:=[];
remprimes:=[j : j in [1..#primes] | not primes[j] in exclprimes]; 
//Indices of remaining primes

for i in remprimes do //We first rebuild the mod p divisors from their sequences.
p:=primes[i];
Ji:=jacs[i];
divspseq:=[divlist[j][i] : j in [1..#divlist]];
divsp:=[];
for k in [1..#divlist] do
ik:=Maximum([j : j in [1..100] | not divspseq[k][j] eq 0]);
Dkp:=&+[divspseq[k][j]*Ji.j : j in [1..ik]];
Append(~divsp,Dkp);
end for;
h:=hom<Codomain(iA) -> Ji | divsp>; //This is the reduction map A->J(X)(\Fp). 
phi:=iA*h;
ppts:=Points(ChangeRing(X,GF(p^2))); //Replace p^2 by p^d when sieving for degree d pts. In particular take d=1 for rational points.
Append(~ratios,Rationals()!(Index(Domain(phi),Kernel(phi))*(#ppts/#Ji)));
// Each step in the sieve, the size of W gets multiplied by approximately
// [B : B \cap Bp]*#Wp/[A : Bp]. We approximate #Wp/[A:Bp] by #X(\F_{p^d})/#Ji.
end for;
m,k:=Min(ratios); //We select the prime that minimizes this ratio.
return remprimes[k]; //and return its index in the set primes.
end function;

// L is a set of known points on X.
// primes is the set of primes of good reduction you want the sieve to consider.
// Also assume A is the abstract abelian group generated by divs in J(X)(\Q)
// such that A.i corresponds to divs[i] for each i.

MWSieve:=function(L,primes,X,A,divs,auts,genusC,deg2pb,deg2npb,I,bp)
// We first compute the information we will need at every prime, to avoid double work.
// This info is needed in the PrimeSelector function.
jacs:=[]; // This will be a list of J(X)(\F_p) for p in primes.
divlist:=[[]: i in [1..#divs]]; // divlist[i] is a list of the divisors reduce(X,Xp,div[i]).
for p in primes do
p;
Fp:=GF(p);
Xpp:=ChangeRing(X,Fp);
CGp,phi,psi:=ClassGroup(Xpp);
Z:=FreeAbelianGroup(1);
degr:=hom<CGp->Z | [ Degree(phi(a))*Z.1 : a in OrderedGenerators(CGp)]>;
JFp:=Kernel(degr); // This is isomorphic to J_X(\F_p).
Append(~jacs,JFp); 
for i in [1..#divs] do
Dip:=JFp!psi(reduce(X,Xpp,divs[i])); 
Dipseq:=Eltseq(Dip);
Dipseq:=Dipseq cat [0*i : i in [1..(100-#Dipseq)]]; //We convert divisors into a sequence of length 100 in order to save them in a list
Append(~divlist[i],Dipseq);
end for;
end for;

// We now set up the sieve.
B,iA:=sub<A|A>; // This subgroup will shrink as we consider more primes.
W:={0*A.1}; // This will be our set of possible B-cosets in A. Will grow.
// Together, B+W \subset A consists of the possible images of unknown (rational)
// points in A. The map X(\Q) \to A is composition of X(\Q) \to J(X)(\Q) and
// multiplication by integer I such that I*J(X)(\Q) \subset A.
exclprimes:=[]; // The set of primes we have considered.

while not Seqset(exclprimes) eq Seqset(primes) do
ind:=PrimeSelector(B,iA,primes,exclprimes,jacs,divlist,X); 
p:=primes[ind]; // We select the next prime.
Append(~exclprimes,p);
p;
Wp,Bp,iAp:=ChabautyInfo(L,p,X,auts,genusC,A,divs,deg2pb,deg2npb,I,bp);
// Whatever Chabauty method we use, it should output a subgroup iAp: Bp \to A and
// a set Wp of Bp-cosets containing the hypothetical unknown points.
if Wp eq {} then return true; end if;
Bnew,iBp:=sub<Bp | B meet Bp>; // We now intersect Bp+Wp and B+W.
iAnew:=iBp*iAp;
A0,pi0:=quo<A | iAnew(Bnew)>;
Ap,pi0p:=quo<A0 | pi0(iAp(Bp))>;
A1,pi01:=quo<A0 | pi0(iA(B))>;
pi1:=pi0*pi01;
pip:=pi0*pi0p;
W:={x@@pi0 : x in {(pi1(y))@@pi01 +k : y in W, k in Kernel(pi01)} | pi0p(x) in pip(Wp)};
// This is the set of Bnew-cosets containing hypothetical points that is left.
B:=Bnew;
iA:=iAnew;
if W eq {} then return true; end if;
#W;
end while;
return #W;
end function;
